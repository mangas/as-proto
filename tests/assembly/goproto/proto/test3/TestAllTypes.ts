// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v1.3.0
//   protoc        v4.25.0

import { Writer, Reader } from "as-proto/assembly";
import { NestedMessage } from "./TestAllTypes/NestedMessage";
import { ForeignMessage } from "./ForeignMessage";
import { ImportMessage } from "./ImportMessage";
import { NestedEnum } from "./TestAllTypes/NestedEnum";
import { ForeignEnum } from "./ForeignEnum";
import { ImportEnum } from "./ImportEnum";

export class TestAllTypes {
  static encode(message: TestAllTypes, writer: Writer): void {
    writer.uint32(648);
    writer.int32(message.singularInt32);

    writer.uint32(656);
    writer.int64(message.singularInt64);

    writer.uint32(664);
    writer.uint32(message.singularUint32);

    writer.uint32(672);
    writer.uint64(message.singularUint64);

    writer.uint32(680);
    writer.sint32(message.singularSint32);

    writer.uint32(688);
    writer.sint64(message.singularSint64);

    writer.uint32(701);
    writer.fixed32(message.singularFixed32);

    writer.uint32(705);
    writer.fixed64(message.singularFixed64);

    writer.uint32(717);
    writer.sfixed32(message.singularSfixed32);

    writer.uint32(721);
    writer.sfixed64(message.singularSfixed64);

    writer.uint32(733);
    writer.float(message.singularFloat);

    writer.uint32(737);
    writer.double(message.singularDouble);

    writer.uint32(744);
    writer.bool(message.singularBool);

    writer.uint32(754);
    writer.string(message.singularString);

    writer.uint32(762);
    writer.bytes(message.singularBytes);

    const singularNestedMessage = message.singularNestedMessage;
    if (singularNestedMessage !== null) {
      writer.uint32(786);
      writer.fork();
      NestedMessage.encode(singularNestedMessage, writer);
      writer.ldelim();
    }

    const singularForeignMessage = message.singularForeignMessage;
    if (singularForeignMessage !== null) {
      writer.uint32(794);
      writer.fork();
      ForeignMessage.encode(singularForeignMessage, writer);
      writer.ldelim();
    }

    const singularImportMessage = message.singularImportMessage;
    if (singularImportMessage !== null) {
      writer.uint32(802);
      writer.fork();
      ImportMessage.encode(singularImportMessage, writer);
      writer.ldelim();
    }

    writer.uint32(808);
    writer.int32(message.singularNestedEnum);

    writer.uint32(816);
    writer.int32(message.singularForeignEnum);

    writer.uint32(824);
    writer.int32(message.singularImportEnum);

    writer.uint32(8);
    writer.int32(message.optionalInt32);

    writer.uint32(16);
    writer.int64(message.optionalInt64);

    writer.uint32(24);
    writer.uint32(message.optionalUint32);

    writer.uint32(32);
    writer.uint64(message.optionalUint64);

    writer.uint32(40);
    writer.sint32(message.optionalSint32);

    writer.uint32(48);
    writer.sint64(message.optionalSint64);

    writer.uint32(61);
    writer.fixed32(message.optionalFixed32);

    writer.uint32(65);
    writer.fixed64(message.optionalFixed64);

    writer.uint32(77);
    writer.sfixed32(message.optionalSfixed32);

    writer.uint32(81);
    writer.sfixed64(message.optionalSfixed64);

    writer.uint32(93);
    writer.float(message.optionalFloat);

    writer.uint32(97);
    writer.double(message.optionalDouble);

    writer.uint32(104);
    writer.bool(message.optionalBool);

    writer.uint32(114);
    writer.string(message.optionalString);

    writer.uint32(122);
    writer.bytes(message.optionalBytes);

    const optionalNestedMessage = message.optionalNestedMessage;
    if (optionalNestedMessage !== null) {
      writer.uint32(146);
      writer.fork();
      NestedMessage.encode(optionalNestedMessage, writer);
      writer.ldelim();
    }

    const optionalForeignMessage = message.optionalForeignMessage;
    if (optionalForeignMessage !== null) {
      writer.uint32(154);
      writer.fork();
      ForeignMessage.encode(optionalForeignMessage, writer);
      writer.ldelim();
    }

    const optionalImportMessage = message.optionalImportMessage;
    if (optionalImportMessage !== null) {
      writer.uint32(162);
      writer.fork();
      ImportMessage.encode(optionalImportMessage, writer);
      writer.ldelim();
    }

    writer.uint32(168);
    writer.int32(message.optionalNestedEnum);

    writer.uint32(176);
    writer.int32(message.optionalForeignEnum);

    writer.uint32(184);
    writer.int32(message.optionalImportEnum);

    const repeatedInt32 = message.repeatedInt32;
    if (repeatedInt32.length !== 0) {
      for (let i: i32 = 0; i < repeatedInt32.length; ++i) {
        writer.uint32(248);
        writer.int32(repeatedInt32[i]);
      }
    }

    const repeatedInt64 = message.repeatedInt64;
    if (repeatedInt64.length !== 0) {
      for (let i: i32 = 0; i < repeatedInt64.length; ++i) {
        writer.uint32(256);
        writer.int64(repeatedInt64[i]);
      }
    }

    const repeatedUint32 = message.repeatedUint32;
    if (repeatedUint32.length !== 0) {
      for (let i: i32 = 0; i < repeatedUint32.length; ++i) {
        writer.uint32(264);
        writer.uint32(repeatedUint32[i]);
      }
    }

    const repeatedUint64 = message.repeatedUint64;
    if (repeatedUint64.length !== 0) {
      for (let i: i32 = 0; i < repeatedUint64.length; ++i) {
        writer.uint32(272);
        writer.uint64(repeatedUint64[i]);
      }
    }

    const repeatedSint32 = message.repeatedSint32;
    if (repeatedSint32.length !== 0) {
      for (let i: i32 = 0; i < repeatedSint32.length; ++i) {
        writer.uint32(280);
        writer.sint32(repeatedSint32[i]);
      }
    }

    const repeatedSint64 = message.repeatedSint64;
    if (repeatedSint64.length !== 0) {
      for (let i: i32 = 0; i < repeatedSint64.length; ++i) {
        writer.uint32(288);
        writer.sint64(repeatedSint64[i]);
      }
    }

    const repeatedFixed32 = message.repeatedFixed32;
    if (repeatedFixed32.length !== 0) {
      for (let i: i32 = 0; i < repeatedFixed32.length; ++i) {
        writer.uint32(301);
        writer.fixed32(repeatedFixed32[i]);
      }
    }

    const repeatedFixed64 = message.repeatedFixed64;
    if (repeatedFixed64.length !== 0) {
      for (let i: i32 = 0; i < repeatedFixed64.length; ++i) {
        writer.uint32(305);
        writer.fixed64(repeatedFixed64[i]);
      }
    }

    const repeatedSfixed32 = message.repeatedSfixed32;
    if (repeatedSfixed32.length !== 0) {
      for (let i: i32 = 0; i < repeatedSfixed32.length; ++i) {
        writer.uint32(317);
        writer.sfixed32(repeatedSfixed32[i]);
      }
    }

    const repeatedSfixed64 = message.repeatedSfixed64;
    if (repeatedSfixed64.length !== 0) {
      for (let i: i32 = 0; i < repeatedSfixed64.length; ++i) {
        writer.uint32(321);
        writer.sfixed64(repeatedSfixed64[i]);
      }
    }

    const repeatedFloat = message.repeatedFloat;
    if (repeatedFloat.length !== 0) {
      for (let i: i32 = 0; i < repeatedFloat.length; ++i) {
        writer.uint32(333);
        writer.float(repeatedFloat[i]);
      }
    }

    const repeatedDouble = message.repeatedDouble;
    if (repeatedDouble.length !== 0) {
      for (let i: i32 = 0; i < repeatedDouble.length; ++i) {
        writer.uint32(337);
        writer.double(repeatedDouble[i]);
      }
    }

    const repeatedBool = message.repeatedBool;
    if (repeatedBool.length !== 0) {
      for (let i: i32 = 0; i < repeatedBool.length; ++i) {
        writer.uint32(344);
        writer.bool(repeatedBool[i]);
      }
    }

    const repeatedString = message.repeatedString;
    if (repeatedString.length !== 0) {
      for (let i: i32 = 0; i < repeatedString.length; ++i) {
        writer.uint32(354);
        writer.string(repeatedString[i]);
      }
    }

    const repeatedBytes = message.repeatedBytes;
    if (repeatedBytes.length !== 0) {
      for (let i: i32 = 0; i < repeatedBytes.length; ++i) {
        writer.uint32(362);
        writer.bytes(repeatedBytes[i]);
      }
    }

    const repeatedNestedMessage = message.repeatedNestedMessage;
    for (let i: i32 = 0; i < repeatedNestedMessage.length; ++i) {
      writer.uint32(386);
      writer.fork();
      NestedMessage.encode(repeatedNestedMessage[i], writer);
      writer.ldelim();
    }

    const repeatedForeignMessage = message.repeatedForeignMessage;
    for (let i: i32 = 0; i < repeatedForeignMessage.length; ++i) {
      writer.uint32(394);
      writer.fork();
      ForeignMessage.encode(repeatedForeignMessage[i], writer);
      writer.ldelim();
    }

    const repeatedImportmessage = message.repeatedImportmessage;
    for (let i: i32 = 0; i < repeatedImportmessage.length; ++i) {
      writer.uint32(402);
      writer.fork();
      ImportMessage.encode(repeatedImportmessage[i], writer);
      writer.ldelim();
    }

    const repeatedNestedEnum = message.repeatedNestedEnum;
    if (repeatedNestedEnum.length !== 0) {
      for (let i: i32 = 0; i < repeatedNestedEnum.length; ++i) {
        writer.uint32(408);
        writer.int32(repeatedNestedEnum[i]);
      }
    }

    const repeatedForeignEnum = message.repeatedForeignEnum;
    if (repeatedForeignEnum.length !== 0) {
      for (let i: i32 = 0; i < repeatedForeignEnum.length; ++i) {
        writer.uint32(416);
        writer.int32(repeatedForeignEnum[i]);
      }
    }

    const repeatedImportenum = message.repeatedImportenum;
    if (repeatedImportenum.length !== 0) {
      for (let i: i32 = 0; i < repeatedImportenum.length; ++i) {
        writer.uint32(424);
        writer.int32(repeatedImportenum[i]);
      }
    }

    const mapInt32Int32 = message.mapInt32Int32;
    if (mapInt32Int32 !== null) {
      const mapInt32Int32Keys = mapInt32Int32.keys();
      for (let i: i32 = 0; i < mapInt32Int32Keys.length; ++i) {
        const mapInt32Int32Key = mapInt32Int32Keys[i];
        writer.uint32(450);
        writer.fork();
        writer.uint32(8);
        writer.int32(mapInt32Int32Key);
        writer.uint32(16);
        writer.int32(mapInt32Int32.get(mapInt32Int32Key));
        writer.ldelim();
      }
    }

    const mapInt64Int64 = message.mapInt64Int64;
    if (mapInt64Int64 !== null) {
      const mapInt64Int64Keys = mapInt64Int64.keys();
      for (let i: i32 = 0; i < mapInt64Int64Keys.length; ++i) {
        const mapInt64Int64Key = mapInt64Int64Keys[i];
        writer.uint32(458);
        writer.fork();
        writer.uint32(8);
        writer.int64(mapInt64Int64Key);
        writer.uint32(16);
        writer.int64(mapInt64Int64.get(mapInt64Int64Key));
        writer.ldelim();
      }
    }

    const mapUint32Uint32 = message.mapUint32Uint32;
    if (mapUint32Uint32 !== null) {
      const mapUint32Uint32Keys = mapUint32Uint32.keys();
      for (let i: i32 = 0; i < mapUint32Uint32Keys.length; ++i) {
        const mapUint32Uint32Key = mapUint32Uint32Keys[i];
        writer.uint32(466);
        writer.fork();
        writer.uint32(8);
        writer.uint32(mapUint32Uint32Key);
        writer.uint32(16);
        writer.uint32(mapUint32Uint32.get(mapUint32Uint32Key));
        writer.ldelim();
      }
    }

    const mapUint64Uint64 = message.mapUint64Uint64;
    if (mapUint64Uint64 !== null) {
      const mapUint64Uint64Keys = mapUint64Uint64.keys();
      for (let i: i32 = 0; i < mapUint64Uint64Keys.length; ++i) {
        const mapUint64Uint64Key = mapUint64Uint64Keys[i];
        writer.uint32(474);
        writer.fork();
        writer.uint32(8);
        writer.uint64(mapUint64Uint64Key);
        writer.uint32(16);
        writer.uint64(mapUint64Uint64.get(mapUint64Uint64Key));
        writer.ldelim();
      }
    }

    const mapSint32Sint32 = message.mapSint32Sint32;
    if (mapSint32Sint32 !== null) {
      const mapSint32Sint32Keys = mapSint32Sint32.keys();
      for (let i: i32 = 0; i < mapSint32Sint32Keys.length; ++i) {
        const mapSint32Sint32Key = mapSint32Sint32Keys[i];
        writer.uint32(482);
        writer.fork();
        writer.uint32(8);
        writer.sint32(mapSint32Sint32Key);
        writer.uint32(16);
        writer.sint32(mapSint32Sint32.get(mapSint32Sint32Key));
        writer.ldelim();
      }
    }

    const mapSint64Sint64 = message.mapSint64Sint64;
    if (mapSint64Sint64 !== null) {
      const mapSint64Sint64Keys = mapSint64Sint64.keys();
      for (let i: i32 = 0; i < mapSint64Sint64Keys.length; ++i) {
        const mapSint64Sint64Key = mapSint64Sint64Keys[i];
        writer.uint32(490);
        writer.fork();
        writer.uint32(8);
        writer.sint64(mapSint64Sint64Key);
        writer.uint32(16);
        writer.sint64(mapSint64Sint64.get(mapSint64Sint64Key));
        writer.ldelim();
      }
    }

    const mapFixed32Fixed32 = message.mapFixed32Fixed32;
    if (mapFixed32Fixed32 !== null) {
      const mapFixed32Fixed32Keys = mapFixed32Fixed32.keys();
      for (let i: i32 = 0; i < mapFixed32Fixed32Keys.length; ++i) {
        const mapFixed32Fixed32Key = mapFixed32Fixed32Keys[i];
        writer.uint32(498);
        writer.fork();
        writer.uint32(13);
        writer.fixed32(mapFixed32Fixed32Key);
        writer.uint32(21);
        writer.fixed32(mapFixed32Fixed32.get(mapFixed32Fixed32Key));
        writer.ldelim();
      }
    }

    const mapFixed64Fixed64 = message.mapFixed64Fixed64;
    if (mapFixed64Fixed64 !== null) {
      const mapFixed64Fixed64Keys = mapFixed64Fixed64.keys();
      for (let i: i32 = 0; i < mapFixed64Fixed64Keys.length; ++i) {
        const mapFixed64Fixed64Key = mapFixed64Fixed64Keys[i];
        writer.uint32(506);
        writer.fork();
        writer.uint32(9);
        writer.fixed64(mapFixed64Fixed64Key);
        writer.uint32(17);
        writer.fixed64(mapFixed64Fixed64.get(mapFixed64Fixed64Key));
        writer.ldelim();
      }
    }

    const mapSfixed32Sfixed32 = message.mapSfixed32Sfixed32;
    if (mapSfixed32Sfixed32 !== null) {
      const mapSfixed32Sfixed32Keys = mapSfixed32Sfixed32.keys();
      for (let i: i32 = 0; i < mapSfixed32Sfixed32Keys.length; ++i) {
        const mapSfixed32Sfixed32Key = mapSfixed32Sfixed32Keys[i];
        writer.uint32(514);
        writer.fork();
        writer.uint32(13);
        writer.sfixed32(mapSfixed32Sfixed32Key);
        writer.uint32(21);
        writer.sfixed32(mapSfixed32Sfixed32.get(mapSfixed32Sfixed32Key));
        writer.ldelim();
      }
    }

    const mapSfixed64Sfixed64 = message.mapSfixed64Sfixed64;
    if (mapSfixed64Sfixed64 !== null) {
      const mapSfixed64Sfixed64Keys = mapSfixed64Sfixed64.keys();
      for (let i: i32 = 0; i < mapSfixed64Sfixed64Keys.length; ++i) {
        const mapSfixed64Sfixed64Key = mapSfixed64Sfixed64Keys[i];
        writer.uint32(522);
        writer.fork();
        writer.uint32(9);
        writer.sfixed64(mapSfixed64Sfixed64Key);
        writer.uint32(17);
        writer.sfixed64(mapSfixed64Sfixed64.get(mapSfixed64Sfixed64Key));
        writer.ldelim();
      }
    }

    const mapInt32Float = message.mapInt32Float;
    if (mapInt32Float !== null) {
      const mapInt32FloatKeys = mapInt32Float.keys();
      for (let i: i32 = 0; i < mapInt32FloatKeys.length; ++i) {
        const mapInt32FloatKey = mapInt32FloatKeys[i];
        writer.uint32(530);
        writer.fork();
        writer.uint32(8);
        writer.int32(mapInt32FloatKey);
        writer.uint32(21);
        writer.float(mapInt32Float.get(mapInt32FloatKey));
        writer.ldelim();
      }
    }

    const mapInt32Double = message.mapInt32Double;
    if (mapInt32Double !== null) {
      const mapInt32DoubleKeys = mapInt32Double.keys();
      for (let i: i32 = 0; i < mapInt32DoubleKeys.length; ++i) {
        const mapInt32DoubleKey = mapInt32DoubleKeys[i];
        writer.uint32(538);
        writer.fork();
        writer.uint32(8);
        writer.int32(mapInt32DoubleKey);
        writer.uint32(17);
        writer.double(mapInt32Double.get(mapInt32DoubleKey));
        writer.ldelim();
      }
    }

    const mapBoolBool = message.mapBoolBool;
    if (mapBoolBool !== null) {
      const mapBoolBoolKeys = mapBoolBool.keys();
      for (let i: i32 = 0; i < mapBoolBoolKeys.length; ++i) {
        const mapBoolBoolKey = mapBoolBoolKeys[i];
        writer.uint32(546);
        writer.fork();
        writer.uint32(8);
        writer.bool(mapBoolBoolKey);
        writer.uint32(16);
        writer.bool(mapBoolBool.get(mapBoolBoolKey));
        writer.ldelim();
      }
    }

    const mapStringString = message.mapStringString;
    if (mapStringString !== null) {
      const mapStringStringKeys = mapStringString.keys();
      for (let i: i32 = 0; i < mapStringStringKeys.length; ++i) {
        const mapStringStringKey = mapStringStringKeys[i];
        writer.uint32(554);
        writer.fork();
        writer.uint32(10);
        writer.string(mapStringStringKey);
        writer.uint32(18);
        writer.string(mapStringString.get(mapStringStringKey));
        writer.ldelim();
      }
    }

    const mapStringBytes = message.mapStringBytes;
    if (mapStringBytes !== null) {
      const mapStringBytesKeys = mapStringBytes.keys();
      for (let i: i32 = 0; i < mapStringBytesKeys.length; ++i) {
        const mapStringBytesKey = mapStringBytesKeys[i];
        writer.uint32(562);
        writer.fork();
        writer.uint32(10);
        writer.string(mapStringBytesKey);
        writer.uint32(18);
        writer.bytes(mapStringBytes.get(mapStringBytesKey));
        writer.ldelim();
      }
    }

    const mapStringNestedMessage = message.mapStringNestedMessage;
    if (mapStringNestedMessage !== null) {
      const mapStringNestedMessageKeys = mapStringNestedMessage.keys();
      for (let i: i32 = 0; i < mapStringNestedMessageKeys.length; ++i) {
        const mapStringNestedMessageKey = mapStringNestedMessageKeys[i];
        writer.uint32(570);
        writer.fork();
        writer.uint32(10);
        writer.string(mapStringNestedMessageKey);
        writer.uint32(18);
        writer.fork();
        NestedMessage.encode(
          mapStringNestedMessage.get(mapStringNestedMessageKey),
          writer
        );
        writer.ldelim();
        writer.ldelim();
      }
    }

    const mapStringNestedEnum = message.mapStringNestedEnum;
    if (mapStringNestedEnum !== null) {
      const mapStringNestedEnumKeys = mapStringNestedEnum.keys();
      for (let i: i32 = 0; i < mapStringNestedEnumKeys.length; ++i) {
        const mapStringNestedEnumKey = mapStringNestedEnumKeys[i];
        writer.uint32(586);
        writer.fork();
        writer.uint32(10);
        writer.string(mapStringNestedEnumKey);
        writer.uint32(16);
        writer.int32(mapStringNestedEnum.get(mapStringNestedEnumKey));
        writer.ldelim();
      }
    }

    writer.uint32(888);
    writer.uint32(message.oneofUint32);

    const oneofNestedMessage = message.oneofNestedMessage;
    if (oneofNestedMessage !== null) {
      writer.uint32(898);
      writer.fork();
      NestedMessage.encode(oneofNestedMessage, writer);
      writer.ldelim();
    }

    writer.uint32(906);
    writer.string(message.oneofString);

    writer.uint32(914);
    writer.bytes(message.oneofBytes);

    writer.uint32(920);
    writer.bool(message.oneofBool);

    writer.uint32(928);
    writer.uint64(message.oneofUint64);

    writer.uint32(941);
    writer.float(message.oneofFloat);

    writer.uint32(945);
    writer.double(message.oneofDouble);

    writer.uint32(952);
    writer.int32(message.oneofEnum);
  }

  static decode(reader: Reader, length: i32): TestAllTypes {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new TestAllTypes();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 81:
          message.singularInt32 = reader.int32();
          break;

        case 82:
          message.singularInt64 = reader.int64();
          break;

        case 83:
          message.singularUint32 = reader.uint32();
          break;

        case 84:
          message.singularUint64 = reader.uint64();
          break;

        case 85:
          message.singularSint32 = reader.sint32();
          break;

        case 86:
          message.singularSint64 = reader.sint64();
          break;

        case 87:
          message.singularFixed32 = reader.fixed32();
          break;

        case 88:
          message.singularFixed64 = reader.fixed64();
          break;

        case 89:
          message.singularSfixed32 = reader.sfixed32();
          break;

        case 90:
          message.singularSfixed64 = reader.sfixed64();
          break;

        case 91:
          message.singularFloat = reader.float();
          break;

        case 92:
          message.singularDouble = reader.double();
          break;

        case 93:
          message.singularBool = reader.bool();
          break;

        case 94:
          message.singularString = reader.string();
          break;

        case 95:
          message.singularBytes = reader.bytes();
          break;

        case 98:
          message.singularNestedMessage = NestedMessage.decode(
            reader,
            reader.uint32()
          );
          break;

        case 99:
          message.singularForeignMessage = ForeignMessage.decode(
            reader,
            reader.uint32()
          );
          break;

        case 100:
          message.singularImportMessage = ImportMessage.decode(
            reader,
            reader.uint32()
          );
          break;

        case 101:
          message.singularNestedEnum = reader.int32();
          break;

        case 102:
          message.singularForeignEnum = reader.int32();
          break;

        case 103:
          message.singularImportEnum = reader.int32();
          break;

        case 1:
          message.optionalInt32 = reader.int32();
          break;

        case 2:
          message.optionalInt64 = reader.int64();
          break;

        case 3:
          message.optionalUint32 = reader.uint32();
          break;

        case 4:
          message.optionalUint64 = reader.uint64();
          break;

        case 5:
          message.optionalSint32 = reader.sint32();
          break;

        case 6:
          message.optionalSint64 = reader.sint64();
          break;

        case 7:
          message.optionalFixed32 = reader.fixed32();
          break;

        case 8:
          message.optionalFixed64 = reader.fixed64();
          break;

        case 9:
          message.optionalSfixed32 = reader.sfixed32();
          break;

        case 10:
          message.optionalSfixed64 = reader.sfixed64();
          break;

        case 11:
          message.optionalFloat = reader.float();
          break;

        case 12:
          message.optionalDouble = reader.double();
          break;

        case 13:
          message.optionalBool = reader.bool();
          break;

        case 14:
          message.optionalString = reader.string();
          break;

        case 15:
          message.optionalBytes = reader.bytes();
          break;

        case 18:
          message.optionalNestedMessage = NestedMessage.decode(
            reader,
            reader.uint32()
          );
          break;

        case 19:
          message.optionalForeignMessage = ForeignMessage.decode(
            reader,
            reader.uint32()
          );
          break;

        case 20:
          message.optionalImportMessage = ImportMessage.decode(
            reader,
            reader.uint32()
          );
          break;

        case 21:
          message.optionalNestedEnum = reader.int32();
          break;

        case 22:
          message.optionalForeignEnum = reader.int32();
          break;

        case 23:
          message.optionalImportEnum = reader.int32();
          break;

        case 31:
          message.repeatedInt32.push(reader.int32());
          break;

        case 32:
          message.repeatedInt64.push(reader.int64());
          break;

        case 33:
          message.repeatedUint32.push(reader.uint32());
          break;

        case 34:
          message.repeatedUint64.push(reader.uint64());
          break;

        case 35:
          message.repeatedSint32.push(reader.sint32());
          break;

        case 36:
          message.repeatedSint64.push(reader.sint64());
          break;

        case 37:
          message.repeatedFixed32.push(reader.fixed32());
          break;

        case 38:
          message.repeatedFixed64.push(reader.fixed64());
          break;

        case 39:
          message.repeatedSfixed32.push(reader.sfixed32());
          break;

        case 40:
          message.repeatedSfixed64.push(reader.sfixed64());
          break;

        case 41:
          message.repeatedFloat.push(reader.float());
          break;

        case 42:
          message.repeatedDouble.push(reader.double());
          break;

        case 43:
          message.repeatedBool.push(reader.bool());
          break;

        case 44:
          message.repeatedString.push(reader.string());
          break;

        case 45:
          message.repeatedBytes.push(reader.bytes());
          break;

        case 48:
          message.repeatedNestedMessage.push(
            NestedMessage.decode(reader, reader.uint32())
          );
          break;

        case 49:
          message.repeatedForeignMessage.push(
            ForeignMessage.decode(reader, reader.uint32())
          );
          break;

        case 50:
          message.repeatedImportmessage.push(
            ImportMessage.decode(reader, reader.uint32())
          );
          break;

        case 51:
          message.repeatedNestedEnum.push(reader.int32());
          break;

        case 52:
          message.repeatedForeignEnum.push(reader.int32());
          break;

        case 53:
          message.repeatedImportenum.push(reader.int32());
          break;

        case 56:
          let mapInt32Int32Key: i32 = 0;
          let mapInt32Int32Value: i32 = 0;
          let mapInt32Int32HasKey: bool = false;
          let mapInt32Int32HasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapInt32Int32Key = reader.int32();
                mapInt32Int32HasKey = true;
                break;

              case 2:
                mapInt32Int32Value = reader.int32();
                mapInt32Int32HasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapInt32Int32 === null) {
              message.mapInt32Int32 = new Map<i32, i32>();
            }
            const mapInt32Int32 = message.mapInt32Int32;
            if (
              mapInt32Int32 !== null &&
              mapInt32Int32HasKey &&
              mapInt32Int32HasValue
            ) {
              mapInt32Int32.set(mapInt32Int32Key, mapInt32Int32Value);
            }
          }
          break;

        case 57:
          let mapInt64Int64Key: i64 = 0;
          let mapInt64Int64Value: i64 = 0;
          let mapInt64Int64HasKey: bool = false;
          let mapInt64Int64HasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapInt64Int64Key = reader.int64();
                mapInt64Int64HasKey = true;
                break;

              case 2:
                mapInt64Int64Value = reader.int64();
                mapInt64Int64HasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapInt64Int64 === null) {
              message.mapInt64Int64 = new Map<i64, i64>();
            }
            const mapInt64Int64 = message.mapInt64Int64;
            if (
              mapInt64Int64 !== null &&
              mapInt64Int64HasKey &&
              mapInt64Int64HasValue
            ) {
              mapInt64Int64.set(mapInt64Int64Key, mapInt64Int64Value);
            }
          }
          break;

        case 58:
          let mapUint32Uint32Key: u32 = 0;
          let mapUint32Uint32Value: u32 = 0;
          let mapUint32Uint32HasKey: bool = false;
          let mapUint32Uint32HasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapUint32Uint32Key = reader.uint32();
                mapUint32Uint32HasKey = true;
                break;

              case 2:
                mapUint32Uint32Value = reader.uint32();
                mapUint32Uint32HasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapUint32Uint32 === null) {
              message.mapUint32Uint32 = new Map<u32, u32>();
            }
            const mapUint32Uint32 = message.mapUint32Uint32;
            if (
              mapUint32Uint32 !== null &&
              mapUint32Uint32HasKey &&
              mapUint32Uint32HasValue
            ) {
              mapUint32Uint32.set(mapUint32Uint32Key, mapUint32Uint32Value);
            }
          }
          break;

        case 59:
          let mapUint64Uint64Key: u64 = 0;
          let mapUint64Uint64Value: u64 = 0;
          let mapUint64Uint64HasKey: bool = false;
          let mapUint64Uint64HasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapUint64Uint64Key = reader.uint64();
                mapUint64Uint64HasKey = true;
                break;

              case 2:
                mapUint64Uint64Value = reader.uint64();
                mapUint64Uint64HasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapUint64Uint64 === null) {
              message.mapUint64Uint64 = new Map<u64, u64>();
            }
            const mapUint64Uint64 = message.mapUint64Uint64;
            if (
              mapUint64Uint64 !== null &&
              mapUint64Uint64HasKey &&
              mapUint64Uint64HasValue
            ) {
              mapUint64Uint64.set(mapUint64Uint64Key, mapUint64Uint64Value);
            }
          }
          break;

        case 60:
          let mapSint32Sint32Key: i32 = 0;
          let mapSint32Sint32Value: i32 = 0;
          let mapSint32Sint32HasKey: bool = false;
          let mapSint32Sint32HasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapSint32Sint32Key = reader.sint32();
                mapSint32Sint32HasKey = true;
                break;

              case 2:
                mapSint32Sint32Value = reader.sint32();
                mapSint32Sint32HasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapSint32Sint32 === null) {
              message.mapSint32Sint32 = new Map<i32, i32>();
            }
            const mapSint32Sint32 = message.mapSint32Sint32;
            if (
              mapSint32Sint32 !== null &&
              mapSint32Sint32HasKey &&
              mapSint32Sint32HasValue
            ) {
              mapSint32Sint32.set(mapSint32Sint32Key, mapSint32Sint32Value);
            }
          }
          break;

        case 61:
          let mapSint64Sint64Key: i64 = 0;
          let mapSint64Sint64Value: i64 = 0;
          let mapSint64Sint64HasKey: bool = false;
          let mapSint64Sint64HasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapSint64Sint64Key = reader.sint64();
                mapSint64Sint64HasKey = true;
                break;

              case 2:
                mapSint64Sint64Value = reader.sint64();
                mapSint64Sint64HasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapSint64Sint64 === null) {
              message.mapSint64Sint64 = new Map<i64, i64>();
            }
            const mapSint64Sint64 = message.mapSint64Sint64;
            if (
              mapSint64Sint64 !== null &&
              mapSint64Sint64HasKey &&
              mapSint64Sint64HasValue
            ) {
              mapSint64Sint64.set(mapSint64Sint64Key, mapSint64Sint64Value);
            }
          }
          break;

        case 62:
          let mapFixed32Fixed32Key: i32 = 0;
          let mapFixed32Fixed32Value: i32 = 0;
          let mapFixed32Fixed32HasKey: bool = false;
          let mapFixed32Fixed32HasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapFixed32Fixed32Key = reader.fixed32();
                mapFixed32Fixed32HasKey = true;
                break;

              case 2:
                mapFixed32Fixed32Value = reader.fixed32();
                mapFixed32Fixed32HasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapFixed32Fixed32 === null) {
              message.mapFixed32Fixed32 = new Map<i32, i32>();
            }
            const mapFixed32Fixed32 = message.mapFixed32Fixed32;
            if (
              mapFixed32Fixed32 !== null &&
              mapFixed32Fixed32HasKey &&
              mapFixed32Fixed32HasValue
            ) {
              mapFixed32Fixed32.set(
                mapFixed32Fixed32Key,
                mapFixed32Fixed32Value
              );
            }
          }
          break;

        case 63:
          let mapFixed64Fixed64Key: i64 = 0;
          let mapFixed64Fixed64Value: i64 = 0;
          let mapFixed64Fixed64HasKey: bool = false;
          let mapFixed64Fixed64HasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapFixed64Fixed64Key = reader.fixed64();
                mapFixed64Fixed64HasKey = true;
                break;

              case 2:
                mapFixed64Fixed64Value = reader.fixed64();
                mapFixed64Fixed64HasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapFixed64Fixed64 === null) {
              message.mapFixed64Fixed64 = new Map<i64, i64>();
            }
            const mapFixed64Fixed64 = message.mapFixed64Fixed64;
            if (
              mapFixed64Fixed64 !== null &&
              mapFixed64Fixed64HasKey &&
              mapFixed64Fixed64HasValue
            ) {
              mapFixed64Fixed64.set(
                mapFixed64Fixed64Key,
                mapFixed64Fixed64Value
              );
            }
          }
          break;

        case 64:
          let mapSfixed32Sfixed32Key: i32 = 0;
          let mapSfixed32Sfixed32Value: i32 = 0;
          let mapSfixed32Sfixed32HasKey: bool = false;
          let mapSfixed32Sfixed32HasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapSfixed32Sfixed32Key = reader.sfixed32();
                mapSfixed32Sfixed32HasKey = true;
                break;

              case 2:
                mapSfixed32Sfixed32Value = reader.sfixed32();
                mapSfixed32Sfixed32HasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapSfixed32Sfixed32 === null) {
              message.mapSfixed32Sfixed32 = new Map<i32, i32>();
            }
            const mapSfixed32Sfixed32 = message.mapSfixed32Sfixed32;
            if (
              mapSfixed32Sfixed32 !== null &&
              mapSfixed32Sfixed32HasKey &&
              mapSfixed32Sfixed32HasValue
            ) {
              mapSfixed32Sfixed32.set(
                mapSfixed32Sfixed32Key,
                mapSfixed32Sfixed32Value
              );
            }
          }
          break;

        case 65:
          let mapSfixed64Sfixed64Key: i64 = 0;
          let mapSfixed64Sfixed64Value: i64 = 0;
          let mapSfixed64Sfixed64HasKey: bool = false;
          let mapSfixed64Sfixed64HasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapSfixed64Sfixed64Key = reader.sfixed64();
                mapSfixed64Sfixed64HasKey = true;
                break;

              case 2:
                mapSfixed64Sfixed64Value = reader.sfixed64();
                mapSfixed64Sfixed64HasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapSfixed64Sfixed64 === null) {
              message.mapSfixed64Sfixed64 = new Map<i64, i64>();
            }
            const mapSfixed64Sfixed64 = message.mapSfixed64Sfixed64;
            if (
              mapSfixed64Sfixed64 !== null &&
              mapSfixed64Sfixed64HasKey &&
              mapSfixed64Sfixed64HasValue
            ) {
              mapSfixed64Sfixed64.set(
                mapSfixed64Sfixed64Key,
                mapSfixed64Sfixed64Value
              );
            }
          }
          break;

        case 66:
          let mapInt32FloatKey: i32 = 0;
          let mapInt32FloatValue: f32 = 0.0;
          let mapInt32FloatHasKey: bool = false;
          let mapInt32FloatHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapInt32FloatKey = reader.int32();
                mapInt32FloatHasKey = true;
                break;

              case 2:
                mapInt32FloatValue = reader.float();
                mapInt32FloatHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapInt32Float === null) {
              message.mapInt32Float = new Map<i32, f32>();
            }
            const mapInt32Float = message.mapInt32Float;
            if (
              mapInt32Float !== null &&
              mapInt32FloatHasKey &&
              mapInt32FloatHasValue
            ) {
              mapInt32Float.set(mapInt32FloatKey, mapInt32FloatValue);
            }
          }
          break;

        case 67:
          let mapInt32DoubleKey: i32 = 0;
          let mapInt32DoubleValue: f64 = 0.0;
          let mapInt32DoubleHasKey: bool = false;
          let mapInt32DoubleHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapInt32DoubleKey = reader.int32();
                mapInt32DoubleHasKey = true;
                break;

              case 2:
                mapInt32DoubleValue = reader.double();
                mapInt32DoubleHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapInt32Double === null) {
              message.mapInt32Double = new Map<i32, f64>();
            }
            const mapInt32Double = message.mapInt32Double;
            if (
              mapInt32Double !== null &&
              mapInt32DoubleHasKey &&
              mapInt32DoubleHasValue
            ) {
              mapInt32Double.set(mapInt32DoubleKey, mapInt32DoubleValue);
            }
          }
          break;

        case 68:
          let mapBoolBoolKey: bool = false;
          let mapBoolBoolValue: bool = false;
          let mapBoolBoolHasKey: bool = false;
          let mapBoolBoolHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapBoolBoolKey = reader.bool();
                mapBoolBoolHasKey = true;
                break;

              case 2:
                mapBoolBoolValue = reader.bool();
                mapBoolBoolHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapBoolBool === null) {
              message.mapBoolBool = new Map<bool, bool>();
            }
            const mapBoolBool = message.mapBoolBool;
            if (
              mapBoolBool !== null &&
              mapBoolBoolHasKey &&
              mapBoolBoolHasValue
            ) {
              mapBoolBool.set(mapBoolBoolKey, mapBoolBoolValue);
            }
          }
          break;

        case 69:
          let mapStringStringKey: string = "";
          let mapStringStringValue: string = "";
          let mapStringStringHasKey: bool = false;
          let mapStringStringHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapStringStringKey = reader.string();
                mapStringStringHasKey = true;
                break;

              case 2:
                mapStringStringValue = reader.string();
                mapStringStringHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapStringString === null) {
              message.mapStringString = new Map<string, string>();
            }
            const mapStringString = message.mapStringString;
            if (
              mapStringString !== null &&
              mapStringStringHasKey &&
              mapStringStringHasValue
            ) {
              mapStringString.set(mapStringStringKey, mapStringStringValue);
            }
          }
          break;

        case 70:
          let mapStringBytesKey: string = "";
          let mapStringBytesValue: Uint8Array = new Uint8Array(0);
          let mapStringBytesHasKey: bool = false;
          let mapStringBytesHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapStringBytesKey = reader.string();
                mapStringBytesHasKey = true;
                break;

              case 2:
                mapStringBytesValue = reader.bytes();
                mapStringBytesHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapStringBytes === null) {
              message.mapStringBytes = new Map<string, Uint8Array>();
            }
            const mapStringBytes = message.mapStringBytes;
            if (
              mapStringBytes !== null &&
              mapStringBytesHasKey &&
              mapStringBytesHasValue
            ) {
              mapStringBytes.set(mapStringBytesKey, mapStringBytesValue);
            }
          }
          break;

        case 71:
          let mapStringNestedMessageKey: string = "";
          let mapStringNestedMessageValue: NestedMessage | null = null;
          let mapStringNestedMessageHasKey: bool = false;
          let mapStringNestedMessageHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapStringNestedMessageKey = reader.string();
                mapStringNestedMessageHasKey = true;
                break;

              case 2:
                mapStringNestedMessageValue = NestedMessage.decode(
                  reader,
                  reader.uint32()
                );
                mapStringNestedMessageHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapStringNestedMessage === null) {
              message.mapStringNestedMessage = new Map<string, NestedMessage>();
            }
            const mapStringNestedMessage = message.mapStringNestedMessage;
            if (
              mapStringNestedMessage !== null &&
              mapStringNestedMessageHasKey &&
              mapStringNestedMessageHasValue &&
              mapStringNestedMessageValue !== null
            ) {
              mapStringNestedMessage.set(
                mapStringNestedMessageKey,
                mapStringNestedMessageValue
              );
            }
          }
          break;

        case 73:
          let mapStringNestedEnumKey: string = "";
          let mapStringNestedEnumValue: NestedEnum = 0;
          let mapStringNestedEnumHasKey: bool = false;
          let mapStringNestedEnumHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                mapStringNestedEnumKey = reader.string();
                mapStringNestedEnumHasKey = true;
                break;

              case 2:
                mapStringNestedEnumValue = reader.int32();
                mapStringNestedEnumHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.mapStringNestedEnum === null) {
              message.mapStringNestedEnum = new Map<string, NestedEnum>();
            }
            const mapStringNestedEnum = message.mapStringNestedEnum;
            if (
              mapStringNestedEnum !== null &&
              mapStringNestedEnumHasKey &&
              mapStringNestedEnumHasValue
            ) {
              mapStringNestedEnum.set(
                mapStringNestedEnumKey,
                mapStringNestedEnumValue
              );
            }
          }
          break;

        case 111:
          message.oneofUint32 = reader.uint32();
          break;

        case 112:
          message.oneofNestedMessage = NestedMessage.decode(
            reader,
            reader.uint32()
          );
          break;

        case 113:
          message.oneofString = reader.string();
          break;

        case 114:
          message.oneofBytes = reader.bytes();
          break;

        case 115:
          message.oneofBool = reader.bool();
          break;

        case 116:
          message.oneofUint64 = reader.uint64();
          break;

        case 117:
          message.oneofFloat = reader.float();
          break;

        case 118:
          message.oneofDouble = reader.double();
          break;

        case 119:
          message.oneofEnum = reader.int32();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  singularInt32: i32;
  singularInt64: i64;
  singularUint32: u32;
  singularUint64: u64;
  singularSint32: i32;
  singularSint64: i64;
  singularFixed32: i32;
  singularFixed64: i64;
  singularSfixed32: i32;
  singularSfixed64: i64;
  singularFloat: f32;
  singularDouble: f64;
  singularBool: bool;
  singularString: string;
  singularBytes: Uint8Array;
  singularNestedMessage: NestedMessage | null;
  singularForeignMessage: ForeignMessage | null;
  singularImportMessage: ImportMessage | null;
  singularNestedEnum: NestedEnum;
  singularForeignEnum: ForeignEnum;
  singularImportEnum: ImportEnum;
  optionalInt32: i32;
  optionalInt64: i64;
  optionalUint32: u32;
  optionalUint64: u64;
  optionalSint32: i32;
  optionalSint64: i64;
  optionalFixed32: i32;
  optionalFixed64: i64;
  optionalSfixed32: i32;
  optionalSfixed64: i64;
  optionalFloat: f32;
  optionalDouble: f64;
  optionalBool: bool;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: NestedMessage | null;
  optionalForeignMessage: ForeignMessage | null;
  optionalImportMessage: ImportMessage | null;
  optionalNestedEnum: NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalImportEnum: ImportEnum;
  repeatedInt32: Array<i32>;
  repeatedInt64: Array<i64>;
  repeatedUint32: Array<u32>;
  repeatedUint64: Array<u64>;
  repeatedSint32: Array<i32>;
  repeatedSint64: Array<i64>;
  repeatedFixed32: Array<i32>;
  repeatedFixed64: Array<i64>;
  repeatedSfixed32: Array<i32>;
  repeatedSfixed64: Array<i64>;
  repeatedFloat: Array<f32>;
  repeatedDouble: Array<f64>;
  repeatedBool: Array<bool>;
  repeatedString: Array<string>;
  repeatedBytes: Array<Uint8Array>;
  repeatedNestedMessage: Array<NestedMessage>;
  repeatedForeignMessage: Array<ForeignMessage>;
  repeatedImportmessage: Array<ImportMessage>;
  repeatedNestedEnum: Array<NestedEnum>;
  repeatedForeignEnum: Array<ForeignEnum>;
  repeatedImportenum: Array<ImportEnum>;
  mapInt32Int32: Map<i32, i32>;
  mapInt64Int64: Map<i64, i64>;
  mapUint32Uint32: Map<u32, u32>;
  mapUint64Uint64: Map<u64, u64>;
  mapSint32Sint32: Map<i32, i32>;
  mapSint64Sint64: Map<i64, i64>;
  mapFixed32Fixed32: Map<i32, i32>;
  mapFixed64Fixed64: Map<i64, i64>;
  mapSfixed32Sfixed32: Map<i32, i32>;
  mapSfixed64Sfixed64: Map<i64, i64>;
  mapInt32Float: Map<i32, f32>;
  mapInt32Double: Map<i32, f64>;
  mapBoolBool: Map<bool, bool>;
  mapStringString: Map<string, string>;
  mapStringBytes: Map<string, Uint8Array>;
  mapStringNestedMessage: Map<string, NestedMessage>;
  mapStringNestedEnum: Map<string, NestedEnum>;
  oneofUint32: u32;
  oneofNestedMessage: NestedMessage | null;
  oneofString: string;
  oneofBytes: Uint8Array;
  oneofBool: bool;
  oneofUint64: u64;
  oneofFloat: f32;
  oneofDouble: f64;
  oneofEnum: NestedEnum;

  constructor(
    singularInt32: i32 = 0,
    singularInt64: i64 = 0,
    singularUint32: u32 = 0,
    singularUint64: u64 = 0,
    singularSint32: i32 = 0,
    singularSint64: i64 = 0,
    singularFixed32: i32 = 0,
    singularFixed64: i64 = 0,
    singularSfixed32: i32 = 0,
    singularSfixed64: i64 = 0,
    singularFloat: f32 = 0.0,
    singularDouble: f64 = 0.0,
    singularBool: bool = false,
    singularString: string = "",
    singularBytes: Uint8Array = new Uint8Array(0),
    singularNestedMessage: NestedMessage | null = null,
    singularForeignMessage: ForeignMessage | null = null,
    singularImportMessage: ImportMessage | null = null,
    singularNestedEnum: NestedEnum = 0,
    singularForeignEnum: ForeignEnum = 0,
    singularImportEnum: ImportEnum = 0,
    optionalInt32: i32 = 0,
    optionalInt64: i64 = 0,
    optionalUint32: u32 = 0,
    optionalUint64: u64 = 0,
    optionalSint32: i32 = 0,
    optionalSint64: i64 = 0,
    optionalFixed32: i32 = 0,
    optionalFixed64: i64 = 0,
    optionalSfixed32: i32 = 0,
    optionalSfixed64: i64 = 0,
    optionalFloat: f32 = 0.0,
    optionalDouble: f64 = 0.0,
    optionalBool: bool = false,
    optionalString: string = "",
    optionalBytes: Uint8Array = new Uint8Array(0),
    optionalNestedMessage: NestedMessage | null = null,
    optionalForeignMessage: ForeignMessage | null = null,
    optionalImportMessage: ImportMessage | null = null,
    optionalNestedEnum: NestedEnum = 0,
    optionalForeignEnum: ForeignEnum = 0,
    optionalImportEnum: ImportEnum = 0,
    repeatedInt32: Array<i32> = [],
    repeatedInt64: Array<i64> = [],
    repeatedUint32: Array<u32> = [],
    repeatedUint64: Array<u64> = [],
    repeatedSint32: Array<i32> = [],
    repeatedSint64: Array<i64> = [],
    repeatedFixed32: Array<i32> = [],
    repeatedFixed64: Array<i64> = [],
    repeatedSfixed32: Array<i32> = [],
    repeatedSfixed64: Array<i64> = [],
    repeatedFloat: Array<f32> = [],
    repeatedDouble: Array<f64> = [],
    repeatedBool: Array<bool> = [],
    repeatedString: Array<string> = [],
    repeatedBytes: Array<Uint8Array> = [],
    repeatedNestedMessage: Array<NestedMessage> = [],
    repeatedForeignMessage: Array<ForeignMessage> = [],
    repeatedImportmessage: Array<ImportMessage> = [],
    repeatedNestedEnum: Array<NestedEnum> = [],
    repeatedForeignEnum: Array<ForeignEnum> = [],
    repeatedImportenum: Array<ImportEnum> = [],
    mapInt32Int32: Map<i32, i32> = new Map(),
    mapInt64Int64: Map<i64, i64> = new Map(),
    mapUint32Uint32: Map<u32, u32> = new Map(),
    mapUint64Uint64: Map<u64, u64> = new Map(),
    mapSint32Sint32: Map<i32, i32> = new Map(),
    mapSint64Sint64: Map<i64, i64> = new Map(),
    mapFixed32Fixed32: Map<i32, i32> = new Map(),
    mapFixed64Fixed64: Map<i64, i64> = new Map(),
    mapSfixed32Sfixed32: Map<i32, i32> = new Map(),
    mapSfixed64Sfixed64: Map<i64, i64> = new Map(),
    mapInt32Float: Map<i32, f32> = new Map(),
    mapInt32Double: Map<i32, f64> = new Map(),
    mapBoolBool: Map<bool, bool> = new Map(),
    mapStringString: Map<string, string> = new Map(),
    mapStringBytes: Map<string, Uint8Array> = new Map(),
    mapStringNestedMessage: Map<string, NestedMessage> = new Map(),
    mapStringNestedEnum: Map<string, NestedEnum> = new Map(),
    oneofUint32: u32 = 0,
    oneofNestedMessage: NestedMessage | null = null,
    oneofString: string = "",
    oneofBytes: Uint8Array = new Uint8Array(0),
    oneofBool: bool = false,
    oneofUint64: u64 = 0,
    oneofFloat: f32 = 0.0,
    oneofDouble: f64 = 0.0,
    oneofEnum: NestedEnum = 0
  ) {
    this.singularInt32 = singularInt32;
    this.singularInt64 = singularInt64;
    this.singularUint32 = singularUint32;
    this.singularUint64 = singularUint64;
    this.singularSint32 = singularSint32;
    this.singularSint64 = singularSint64;
    this.singularFixed32 = singularFixed32;
    this.singularFixed64 = singularFixed64;
    this.singularSfixed32 = singularSfixed32;
    this.singularSfixed64 = singularSfixed64;
    this.singularFloat = singularFloat;
    this.singularDouble = singularDouble;
    this.singularBool = singularBool;
    this.singularString = singularString;
    this.singularBytes = singularBytes;
    this.singularNestedMessage = singularNestedMessage;
    this.singularForeignMessage = singularForeignMessage;
    this.singularImportMessage = singularImportMessage;
    this.singularNestedEnum = singularNestedEnum;
    this.singularForeignEnum = singularForeignEnum;
    this.singularImportEnum = singularImportEnum;
    this.optionalInt32 = optionalInt32;
    this.optionalInt64 = optionalInt64;
    this.optionalUint32 = optionalUint32;
    this.optionalUint64 = optionalUint64;
    this.optionalSint32 = optionalSint32;
    this.optionalSint64 = optionalSint64;
    this.optionalFixed32 = optionalFixed32;
    this.optionalFixed64 = optionalFixed64;
    this.optionalSfixed32 = optionalSfixed32;
    this.optionalSfixed64 = optionalSfixed64;
    this.optionalFloat = optionalFloat;
    this.optionalDouble = optionalDouble;
    this.optionalBool = optionalBool;
    this.optionalString = optionalString;
    this.optionalBytes = optionalBytes;
    this.optionalNestedMessage = optionalNestedMessage;
    this.optionalForeignMessage = optionalForeignMessage;
    this.optionalImportMessage = optionalImportMessage;
    this.optionalNestedEnum = optionalNestedEnum;
    this.optionalForeignEnum = optionalForeignEnum;
    this.optionalImportEnum = optionalImportEnum;
    this.repeatedInt32 = repeatedInt32;
    this.repeatedInt64 = repeatedInt64;
    this.repeatedUint32 = repeatedUint32;
    this.repeatedUint64 = repeatedUint64;
    this.repeatedSint32 = repeatedSint32;
    this.repeatedSint64 = repeatedSint64;
    this.repeatedFixed32 = repeatedFixed32;
    this.repeatedFixed64 = repeatedFixed64;
    this.repeatedSfixed32 = repeatedSfixed32;
    this.repeatedSfixed64 = repeatedSfixed64;
    this.repeatedFloat = repeatedFloat;
    this.repeatedDouble = repeatedDouble;
    this.repeatedBool = repeatedBool;
    this.repeatedString = repeatedString;
    this.repeatedBytes = repeatedBytes;
    this.repeatedNestedMessage = repeatedNestedMessage;
    this.repeatedForeignMessage = repeatedForeignMessage;
    this.repeatedImportmessage = repeatedImportmessage;
    this.repeatedNestedEnum = repeatedNestedEnum;
    this.repeatedForeignEnum = repeatedForeignEnum;
    this.repeatedImportenum = repeatedImportenum;
    this.mapInt32Int32 = mapInt32Int32;
    this.mapInt64Int64 = mapInt64Int64;
    this.mapUint32Uint32 = mapUint32Uint32;
    this.mapUint64Uint64 = mapUint64Uint64;
    this.mapSint32Sint32 = mapSint32Sint32;
    this.mapSint64Sint64 = mapSint64Sint64;
    this.mapFixed32Fixed32 = mapFixed32Fixed32;
    this.mapFixed64Fixed64 = mapFixed64Fixed64;
    this.mapSfixed32Sfixed32 = mapSfixed32Sfixed32;
    this.mapSfixed64Sfixed64 = mapSfixed64Sfixed64;
    this.mapInt32Float = mapInt32Float;
    this.mapInt32Double = mapInt32Double;
    this.mapBoolBool = mapBoolBool;
    this.mapStringString = mapStringString;
    this.mapStringBytes = mapStringBytes;
    this.mapStringNestedMessage = mapStringNestedMessage;
    this.mapStringNestedEnum = mapStringNestedEnum;
    this.oneofUint32 = oneofUint32;
    this.oneofNestedMessage = oneofNestedMessage;
    this.oneofString = oneofString;
    this.oneofBytes = oneofBytes;
    this.oneofBool = oneofBool;
    this.oneofUint64 = oneofUint64;
    this.oneofFloat = oneofFloat;
    this.oneofDouble = oneofDouble;
    this.oneofEnum = oneofEnum;
  }
}
